import java.util.*;

public class Dijkstra {
    private int V;
    private LinkedList<Edge>[] adj; // список смежности

    static class Edge {
        int v, weight;
        Edge(int v, int weight) {
            this.v = v;
            this.weight = weight;
        }
    }

    public Dijkstra(int v) {
        V = v;
        adj = new LinkedList[V];
        for (int i = 0; i < V; i++) {
            adj[i] = new LinkedList<>();
        }
    }

    public void addEdge(int u, int v, int weight) {
        adj[u].add(new Edge(v, weight));
        // Для ориентированного графа не добавляем обратное ребро
    }

    public void shortestPath(int start) {
        int[] dist = new int[V];
        Arrays.fill(dist, Integer.MAX_VALUE);
        dist[start] = 0;

        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));
        pq.offer(new int[]{start, 0});

        while (!pq.isEmpty()) {
            int[] current = pq.poll();
            int u = current[0], d = current[1];

            if (d > dist[u]) continue;

            for (Edge edge : adj[u]) {
                int v = edge.v, weight = edge.weight;
                if (dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.offer(new int[]{v, dist[v]});
                }
            }
        }

        System.out.println("Кратчайшие расстояния от вершины " + start + ":");
        for (int i = 0; i < V; i++) {
            if (dist[i] == Integer.MAX_VALUE)
                System.out.println(i + ": недостижимо");
            else
                System.out.println(i + ": " + dist[i]);
        }
    }

    public static void main(String[] args) {
        Dijkstra g = new Dijkstra(6);

        g.addEdge(0, 1, 7);
        g.addEdge(0, 2, 9);
        g.addEdge(0, 5, 14);
        g.addEdge(1, 2, 10);
        g.addEdge(1, 3, 15);
        g.addEdge(2, 3, 11);
        g.addEdge(2, 5, 2);
        g.addEdge(3, 4, 6);
        g.addEdge(4, 5, 9);

        g.shortestPath(0);
    }
}
